// Prisma Schema - Tienda Online 2025
// Multi-tenant E-commerce SaaS Platform

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ============ MULTI-TENANCY ============

model Tenant {
  id                    String   @id @default(cuid())
  name                  String
  slug                  String   @unique
  logo                  String?
  primaryColor          String   @default("#0A1128") // Azul Marino
  accentColor           String   @default("#D4AF37")  // Dorado
  domain                String?  @unique

  // Configuración de negocio
  featureFlags          Json     @default("{}")

  // Relaciones
  users                 User[]
  products              Product[]
  categories            Category[]
  carts                 Cart[]
  orders                Order[]
  coupons               Coupon[]
  emailCampaigns        EmailCampaign[]
  emailSubscribers      EmailSubscriber[]
  emailAutomations      EmailAutomation[]
  emailSends            EmailSend[]
  savedSearches         SavedSearch[]
  searchQueries         SearchQuery[]
  subscriptions         Subscription[]

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([slug])
  @@index([domain])
}

// ============ AUTENTICACIÓN ============

model User {
  id                    String   @id @default(cuid())
  email                 String
  emailVerified         DateTime?
  password              String?  // null si usa OAuth
  name                  String?
  image                 String?

  // Tenant & Role
  tenantId              String?  // null para SUPER_ADMIN
  role                  UserRole @default(CUSTOMER)
  status                UserStatus @default(ACTIVE) // ✅ SECURITY [P1.2]: User account status
  sessionVersion        Int      @default(1) // ✅ SECURITY [P1.5]: Session invalidation mechanism

  // OAuth
  googleId              String?  @unique
  googleAccessToken     String?
  googleRefreshToken    String?

  // Stripe
  stripeCustomerId      String?  @unique

  // Profile
  phone                 String?
  birthDate             DateTime?
  addresses             Address[]

  // Relations
  tenant                Tenant?  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  accounts              Account[]
  sessions              Session[]
  carts                 Cart[]
  orders                Order[]
  reviews               Review[]
  notifications         Notification[]
  notificationPreference NotificationPreference?
  savedSearches         SavedSearch[]
  searchQueries         SearchQuery[]
  savedPaymentMethods   SavedPaymentMethod[]
  subscriptions         Subscription[]

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@unique([email, tenantId]) // Email único por tenant
  @@index([tenantId])
  @@index([role])
  @@index([status]) // ✅ SECURITY [P1.2]: Index for status queries
}

// Auth.js models
model Account {
  id                    String   @id @default(cuid())
  userId                String
  type                  String
  provider              String
  providerAccountId     String
  refresh_token         String?  @db.Text
  access_token          String?  @db.Text
  expires_at            Int?
  token_type            String?
  scope                 String?
  id_token              String?  @db.Text
  session_state         String?

  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id                    String   @id @default(cuid())
  sessionToken          String   @unique
  userId                String
  expires               DateTime

  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier            String
  token                 String   @unique
  expires               DateTime

  @@unique([identifier, token])
  @@index([token])
}

enum UserRole {
  SUPER_ADMIN
  STORE_OWNER
  CUSTOMER
}

// ✅ SECURITY [P1.2]: User account status for access control
enum UserStatus {
  ACTIVE      // User can access the system
  SUSPENDED   // Temporarily disabled (e.g., payment issues, violation)
  BLOCKED     // Permanently disabled (e.g., abuse, fraud)
}

// ============ PRODUCTOS ============

model Category {
  id                    String   @id @default(cuid())
  tenantId              String
  name                  String
  slug                  String
  description           String?  @db.Text
  image                 String?
  parentId              String?

  // Relations
  tenant                Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  parent                Category? @relation("SubCategories", fields: [parentId], references: [id], onDelete: SetNull)
  subcategories         Category[] @relation("SubCategories")
  products              Product[]

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@unique([tenantId, slug])
  @@index([tenantId])
  @@index([parentId])
  @@index([tenantId, parentId]) // Optimiza listado de subcategorías por tenant
}

model Product {
  id                    String   @id @default(cuid())
  tenantId              String
  categoryId            String

  // Info básica
  name                  String
  slug                  String
  description           String   @db.Text
  shortDescription      String?
  sku                   String

  // Precios
  basePrice             Decimal  @db.Decimal(10, 2)
  salePrice             Decimal? @db.Decimal(10, 2)
  salePriceExpiresAt    DateTime?

  // Inventario
  stock                 Int      @default(0)
  reserved              Int      @default(0) // Para órdenes pendientes de pago
  lowStockThreshold     Int      @default(5)

  // Logística
  weight                Decimal  @db.Decimal(8, 2) // kg
  length                Decimal  @db.Decimal(8, 2) // cm
  width                 Decimal  @db.Decimal(8, 2)
  height                Decimal  @db.Decimal(8, 2)

  // Metadata
  tags                  String[] @default([])
  seo                   Json     @default("{}")

  // Estados
  published             Boolean  @default(false)
  featured              Boolean  @default(false)
  archivedAt            DateTime? // Soft delete - NULL = activo, NOT NULL = archivado

  // Relations
  tenant                Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  category              Category @relation(fields: [categoryId], references: [id])
  variants              ProductVariant[]
  images                ProductImage[]
  cartItems             CartItem[]
  orderItems            OrderItem[]
  reviews               Review[]
  reservationItems      ReservationItem[]
  inventoryLogs         InventoryLog[]

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@unique([tenantId, sku])
  @@unique([tenantId, slug]) // Búsqueda única de productos por slug
  @@index([tenantId])
  @@index([categoryId])
  @@index([published])
  @@index([featured])
  @@index([archivedAt]) // Filter archived products
  @@index([tenantId, published]) // Listar productos publicados por tenant
  @@index([tenantId, categoryId, published]) // Filtrar por categoría y estado
  @@index([tenantId, featured, published]) // Productos destacados publicados
  @@index([tenantId, createdAt]) // Ordenar productos por fecha de creación
  @@index([tenantId, archivedAt]) // Filter active/archived products by tenant
  @@index([stock]) // Detectar productos con bajo stock
  @@fulltext([name, description]) // Full-text search index
}

model ProductVariant {
  id                    String   @id @default(cuid())
  productId             String

  // Atributos
  size                  String?
  color                 String?
  model                 String?

  // Stock & Precio específico
  sku                   String
  price                 Decimal? @db.Decimal(10, 2) // null = usar price del producto
  stock                 Int

  // Media
  imageId               String?

  // Relations
  product               Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  image                 ProductImage? @relation(fields: [imageId], references: [id])
  cartItems             CartItem[]
  orderItems            OrderItem[]
  reservationItems      ReservationItem[]

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@unique([productId, sku])
  @@index([productId])
}

model ProductImage {
  id                    String   @id @default(cuid())
  productId             String

  url                   String
  alt                   String?
  order                 Int      @default(0)
  isVideo               Boolean  @default(false)

  // Relations
  product               Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  variants              ProductVariant[]

  @@index([productId])
}

// ============ CARRITO ============

model Cart {
  id                    String   @id @default(cuid())
  userId                String
  tenantId              String

  // Relations
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant                Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  items                 CartItem[]

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@unique([userId, tenantId]) // Un carrito por usuario por tenant
  @@index([userId])
  @@index([tenantId])
}

model CartItem {
  id                    String   @id @default(cuid())
  cartId                String
  productId             String
  variantId             String?

  quantity              Int
  priceSnapshot         Decimal  @db.Decimal(10, 2) // Precio al momento de agregar

  // Relations
  cart                  Cart     @relation(fields: [cartId], references: [id], onDelete: Cascade)
  product               Product  @relation(fields: [productId], references: [id])
  variant               ProductVariant? @relation(fields: [variantId], references: [id])

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@unique([cartId, productId, variantId]) // Un item único por combinación
  @@index([cartId])
  @@index([productId])
}

// ============ ÓRDENES ============

model Order {
  id                    String   @id @default(cuid())
  tenantId              String
  userId                String?  // Null for guest checkouts

  // Guest details
  customerName          String?
  customerEmail         String?

  // Números únicos
  orderNumber           String   @unique // ej: ORD-2025-001234

  // Subtotales
  subtotal              Decimal  @db.Decimal(12, 2)
  shippingCost          Decimal  @db.Decimal(10, 2) @default(0)
  tax                   Decimal  @db.Decimal(10, 2)
  discount              Decimal  @db.Decimal(10, 2) @default(0)
  total                 Decimal  @db.Decimal(12, 2)

  // Dirección & Envío
  shippingAddressId     String
  billingAddressId      String?
  shippingMethod        String   @default("standard")
  trackingNumber        String?

  // Pago
  paymentMethod         PaymentMethod
  paymentStatus         PaymentStatus @default(PENDING)
  paymentId             String?  // Stripe/Mercado Pago ID

  // Estado general
  status                OrderStatus @default(PENDING)
  notes                 String?  @db.Text
  adminNotes            String?  @db.Text

  // Cupones
  couponCode            String?

  // Relations
  tenant                Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user                  User?    @relation(fields: [userId], references: [id])
  items                 OrderItem[]
  shippingAddress       Address  @relation("ShippingAddress", fields: [shippingAddressId], references: [id])
  billingAddress        Address? @relation("BillingAddress", fields: [billingAddressId], references: [id])
  inventoryReservation  InventoryReservation?
  invoices              Invoice[]
  disputes              Dispute[]

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([tenantId])
  @@index([userId])
  @@index([status])
  @@index([paymentStatus])
  @@index([createdAt])
  @@index([tenantId, status]) // Filtrar órdenes por tenant y estado
  @@index([tenantId, createdAt]) // Ordenar órdenes por fecha por tenant
  @@index([userId, status]) // Órdenes de usuario por estado
  @@index([tenantId, status, createdAt]) // Combinado: filtrar y ordenar
  @@index([tenantId, paymentStatus]) // Filtrar por estado de pago
  @@index([paymentMethod]) // Reportes por método de pago
}

model OrderItem {
  id                    String   @id @default(cuid())
  orderId               String
  productId             String
  variantId             String?

  quantity              Int
  priceAtPurchase       Decimal  @db.Decimal(10, 2)

  // Relations
  order                 Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product               Product  @relation(fields: [productId], references: [id])
  variant               ProductVariant? @relation(fields: [variantId], references: [id])

  @@index([orderId])
  @@index([productId])
}

model Address {
  id                    String   @id @default(cuid())
  userId                String?

  name                  String
  email                 String
  phone                 String

  street                String
  city                  String
  state                 String
  postalCode            String
  country               String   @default("MX")

  isDefault             Boolean  @default(false)

  // Relations
  user                  User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  ordersAsShipping      Order[]  @relation("ShippingAddress")
  ordersAsBilling       Order[]  @relation("BillingAddress")

  @@index([userId])
}

enum PaymentMethod {
  CREDIT_CARD
  STRIPE
  MERCADO_PAGO
  PAYPAL
  OXXO
  BANK_TRANSFER
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
}

enum OrderStatus {
  PENDING        // Aguardando pago
  PROCESSING     // Pagado, preparando envío
  SHIPPED        // En tránsito
  DELIVERED      // Entregado
  CANCELLED      // Cancelado
  REFUNDED       // Reembolsado
}

// ============ RESEÑAS ============

model Review {
  id                    String   @id @default(cuid())
  productId             String
  userId                String
  orderId               String?  // Compra verificada

  rating                Int      // 1-5
  title                 String
  content               String   @db.Text

  status                ReviewStatus @default(PENDING)

  // Social proof features
  helpfulCount          Int      @default(0)
  notHelpfulCount       Int      @default(0)
  images                String[] @default([]) // URLs de fotos del review
  verifiedPurchase      Boolean  @default(false)

  // Seller response
  sellerResponse        String?  @db.Text
  sellerResponseAt      DateTime?

  // Relations
  product               Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  helpfulVotes          ReviewHelpfulVote[]

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@unique([productId, userId]) // Un review por producto por usuario
  @@index([productId])
  @@index([userId])
  @@index([status])
  @@index([productId, status]) // Reviews aprobadas de un producto
  @@index([productId, rating]) // Ordenar reviews por calificación
  @@index([productId, createdAt]) // Reviews más recientes primero
}

model ReviewHelpfulVote {
  id                    String   @id @default(cuid())
  reviewId              String
  userId                String
  vote                  VoteType // HELPFUL or NOT_HELPFUL

  // Relations
  review                Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)

  createdAt             DateTime @default(now())

  @@unique([reviewId, userId]) // Un voto por review por usuario
  @@index([reviewId])
  @@index([userId])
}

enum VoteType {
  HELPFUL
  NOT_HELPFUL
}

enum ReviewStatus {
  PENDING
  APPROVED
  REJECTED
}

// ============ CUPONES ============

model Coupon {
  id                    String   @id @default(cuid())
  tenantId              String

  code                  String
  description           String?

  // Tipo de descuento
  type                  CouponType // PERCENTAGE | FIXED
  value                 Decimal  @db.Decimal(10, 2)

  // Condiciones
  minPurchase           Decimal? @db.Decimal(12, 2)
  maxDiscount           Decimal? @db.Decimal(10, 2)

  // Aplicabilidad
  applicableToAll       Boolean  @default(true)
  applicableProducts    String[] @default([]) // Product IDs
  applicableCategories  String[] @default([]) // Category IDs

  // Uso
  maxUses               Int?
  usedCount             Int      @default(0)
  maxUsesPerUser        Int      @default(1)

  // Validez
  startDate             DateTime
  expiresAt             DateTime

  // Relations
  tenant                Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@unique([tenantId, code])
  @@index([tenantId])
  @@index([expiresAt])
  @@index([tenantId, expiresAt]) // Cupones activos por tenant
  @@index([startDate, expiresAt]) // Validación de vigencia
}

enum CouponType {
  PERCENTAGE
  FIXED
}

// ============ INVENTORY MANAGEMENT ============

model InventoryReservation {
  id                    String   @id @default(cuid())
  orderId               String   @unique
  status                ReservationStatus @default(RESERVED)

  reservedAt            DateTime @default(now())
  confirmedAt           DateTime?

  // Relations
  order                 Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  items                 ReservationItem[]

  @@index([orderId])
  @@index([status])
}

model ReservationItem {
  id                    String   @id @default(cuid())
  reservationId         String
  productId             String
  variantId             String?

  reservedQuantity      Int

  // Relations
  reservation           InventoryReservation @relation(fields: [reservationId], references: [id], onDelete: Cascade)
  product               Product  @relation(fields: [productId], references: [id])
  variant               ProductVariant? @relation(fields: [variantId], references: [id])

  @@index([reservationId])
  @@index([productId])
}

model InventoryLog {
  id                    String   @id @default(cuid())
  productId             String

  adjustment            Int      // Positive or negative
  reason                InventoryReason
  previousStock         Int
  newStock              Int

  createdAt             DateTime @default(now())

  // Relations
  product               Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([productId])
  @@index([createdAt])
}

enum ReservationStatus {
  RESERVED
  CONFIRMED
  CANCELLED
}

enum InventoryReason {
  RECOUNT
  RETURN
  DAMAGE
  PURCHASE
  OTHER
}

// ============ NOTIFICATIONS & EMAILS ============

model Notification {
  id                    String   @id @default(cuid())
  userId                String
  tenantId              String?

  // Notification content
  type                  NotificationType
  title                 String
  message               String   @db.Text
  actionUrl             String?
  metadata              Json?    @db.Json

  // Status
  read                  Boolean  @default(false)
  readAt                DateTime?

  // Relations
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([userId, read])
  @@index([tenantId])
  @@index([createdAt])
}

model EmailLog {
  id                    String   @id @default(cuid())
  tenantId              String?
  userId                String?

  // Email details
  to                    String
  from                  String
  subject               String
  template              EmailTemplate

  // Tracking
  status                EmailStatus @default(PENDING)
  sentAt                DateTime?
  deliveredAt           DateTime?
  openedAt              DateTime?
  clickedAt             DateTime?
  bouncedAt             DateTime?

  // Provider info
  providerMessageId     String?  // Resend message ID
  error                 String?  @db.Text
  metadata              Json?    @db.Json

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([userId])
  @@index([tenantId])
  @@index([status])
  @@index([template])
  @@index([createdAt])
}

model NotificationPreference {
  id                    String   @id @default(cuid())
  userId                String   @unique

  // Email preferences
  emailOrderConfirmation        Boolean @default(true)
  emailOrderShipped             Boolean @default(true)
  emailOrderDelivered           Boolean @default(true)
  emailOrderCancelled           Boolean @default(true)
  emailRefundProcessed          Boolean @default(true)
  emailNewReview                Boolean @default(true)
  emailProductRestocked         Boolean @default(false)
  emailPromotions               Boolean @default(true)
  emailNewsletters              Boolean @default(true)

  // In-app preferences
  inAppOrderUpdates             Boolean @default(true)
  inAppNewReviews               Boolean @default(true)
  inAppPromotions               Boolean @default(true)
  inAppProductRestocked         Boolean @default(true)

  // Push preferences (future)
  pushOrderUpdates              Boolean @default(false)
  pushPromotions                Boolean @default(false)

  // Relations
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([userId])
}

enum NotificationType {
  ORDER_CONFIRMED
  ORDER_SHIPPED
  ORDER_DELIVERED
  ORDER_CANCELLED
  REFUND_PROCESSED
  NEW_REVIEW
  PRODUCT_RESTOCKED
  PROMOTION
  SYSTEM
  CUSTOM
}

enum EmailTemplate {
  ORDER_CONFIRMATION
  ORDER_SHIPPED
  ORDER_DELIVERED
  ORDER_CANCELLED
  REFUND_PROCESSED
  PAYMENT_FAILED
  ACCOUNT_VERIFICATION
  PASSWORD_RESET
  WELCOME
  NEWSLETTER
  PROMOTION
  REVIEW_REQUEST
  PRODUCT_RESTOCKED
  CUSTOM
}

enum EmailStatus {
  PENDING
  SENT
  DELIVERED
  OPENED
  CLICKED
  BOUNCED
  FAILED
}

// ============ EMAIL MARKETING ============

model EmailCampaign {
  id                    String   @id @default(cuid())
  tenantId              String
  
  // Campaign details
  name                  String
  subject               String
  previewText           String?
  fromName              String
  fromEmail             String
  replyTo               String?
  
  // Content
  htmlContent           String   @db.Text
  textContent           String?  @db.Text
  templateData          Json?    @db.Json
  
  // Targeting
  segmentRules          Json?    @db.Json  // Filter rules for recipients
  
  // Scheduling
  status                CampaignStatus @default(DRAFT)
  scheduledFor          DateTime?
  sentAt                DateTime?
  
  // A/B Testing
  subjectVariants       Json?    @db.Json  // Different subject lines to test
  
  // Relations
  tenant                Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  sends                 EmailSend[]
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  @@index([tenantId])
  @@index([status])
  @@index([scheduledFor])
}

model EmailSubscriber {
  id                    String   @id @default(cuid())
  tenantId              String
  
  // Contact info
  email                 String
  firstName             String?
  lastName              String?
  phone                 String?
  
  // Subscription
  status                SubscriberStatus @default(SUBSCRIBED)
  subscribedAt          DateTime @default(now())
  unsubscribedAt        DateTime?
  unsubscribeReason     String?
  
  // Segmentation
  tags                  String[]
  customFields          Json?    @db.Json
  
  // Engagement
  lastEmailOpenedAt     DateTime?
  lastEmailClickedAt    DateTime?
  
  // Relations
  tenant                Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  sends                 EmailSend[]
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  @@unique([tenantId, email])
  @@index([tenantId])
  @@index([status])
  @@index([email])
}

model EmailAutomation {
  id                    String   @id @default(cuid())
  tenantId              String
  
  // Automation details
  name                  String
  description           String?
  
  // Trigger
  triggerType           AutomationTrigger
  triggerDelay          Int?     // Minutes to wait after trigger
  triggerRules          Json?    @db.Json
  
  // Email content
  subject               String
  htmlContent           String   @db.Text
  textContent           String?  @db.Text
  fromName              String
  fromEmail             String
  
  // Status
  active                Boolean  @default(false)
  
  // Stats
  totalTriggered        Int      @default(0)
  totalSent             Int      @default(0)
  
  // Relations
  tenant                Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  sends                 EmailSend[]
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  @@index([tenantId])
  @@index([active])
  @@index([triggerType])
}

model EmailSend {
  id                    String   @id @default(cuid())
  tenantId              String
  
  // Campaign or Automation
  campaignId            String?
  automationId          String?
  subscriberId          String
  
  // Email details
  toEmail               String
  subject               String
  
  // Tracking
  status                EmailStatus @default(PENDING)
  sentAt                DateTime?
  deliveredAt           DateTime?
  openedAt              DateTime?
  clickedAt             DateTime?
  bouncedAt             DateTime?
  opened                Int      @default(0)  // Count of opens
  clicked               Int      @default(0)  // Count of clicks
  
  // Provider
  providerMessageId     String?
  error                 String?  @db.Text
  
  // Relations
  tenant                Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  campaign              EmailCampaign? @relation(fields: [campaignId], references: [id], onDelete: SetNull)
  automation            EmailAutomation? @relation(fields: [automationId], references: [id], onDelete: SetNull)
  subscriber            EmailSubscriber @relation(fields: [subscriberId], references: [id], onDelete: Cascade)
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  @@index([tenantId])
  @@index([campaignId])
  @@index([automationId])
  @@index([subscriberId])
  @@index([status])
  @@index([toEmail])
}

// ============ ENUMS FOR EMAIL MARKETING ============

enum CampaignStatus {
  DRAFT
  SCHEDULED
  SENDING
  SENT
  PAUSED
  CANCELLED
}

enum SubscriberStatus {
  SUBSCRIBED
  UNSUBSCRIBED
  BOUNCED
  COMPLAINED
}

enum AutomationTrigger {
  WELCOME          // When user signs up
  ABANDONED_CART   // Cart not completed
  POST_PURCHASE    // After order completion
  REVIEW_REQUEST   // Ask for product review
  WIN_BACK         // Re-engage inactive customers
  BIRTHDAY         // Customer birthday
  CUSTOM           // Custom trigger
}

// ============ SEARCH & DISCOVERY ============

model SavedSearch {
  id                    String   @id @default(cuid())
  userId                String
  tenantId              String

  // Search details
  name                  String   // "Laptops baratos"
  query                 String   // "laptop"
  filters               Json?    @db.Json // { minPrice: 100, maxPrice: 500, categoryId: "..." }

  // Notifications
  notifyOnNewResults    Boolean  @default(false)
  lastNotifiedAt        DateTime?

  // Relations
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant                Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([userId])
  @@index([tenantId])
}

model SearchQuery {
  id                    String   @id @default(cuid())
  tenantId              String

  // Search details
  query                 String
  resultsCount          Int
  filters               Json?    @db.Json

  // User context (optional for anonymous searches)
  userId                String?
  sessionId             String?

  // Metadata
  userAgent             String?  @db.Text
  locale                String?

  // Relations
  tenant                Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user                  User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  createdAt             DateTime @default(now())

  @@index([tenantId, createdAt])
  @@index([query])
  @@index([tenantId, query])
  @@index([userId])
}

// ============ PAYMENT ADVANCED FEATURES ============

model SavedPaymentMethod {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  stripeId    String   @unique // Stripe Payment Method ID
  brand       String   // "visa", "mastercard", etc
  last4       String   // Last 4 digits
  expMonth    Int
  expYear     Int
  isDefault   Boolean  @default(false)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([userId, isDefault])
}

model Subscription {
  id                  String   @id @default(cuid())
  userId              String
  tenantId            String
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant              Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  stripeId            String   @unique // Stripe Subscription ID
  stripeCustomerId    String
  stripePriceId       String

  status              String   // active, canceled, past_due, etc
  currentPeriodStart  DateTime
  currentPeriodEnd    DateTime
  canceledAt          DateTime?

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([userId])
  @@index([tenantId])
  @@index([status])
}

model Invoice {
  id          String   @id @default(cuid())
  tenantId    String
  orderId     String
  order       Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)

  number      String   @unique // INV-2025-001234
  stripeId    String?  @unique

  subtotal    Decimal  @db.Decimal(12, 2)
  tax         Decimal  @db.Decimal(10, 2)
  total       Decimal  @db.Decimal(12, 2)

  status      InvoiceStatus @default(DRAFT)

  issuedAt    DateTime @default(now())
  dueAt       DateTime?
  paidAt      DateTime?

  pdfUrl      String?  // S3/Vercel Blob URL

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([tenantId])
  @@index([orderId])
  @@index([status])
}

enum InvoiceStatus {
  DRAFT
  SENT
  PAID
  OVERDUE
  VOID
}

model WebhookEvent {
  id             String   @id @default(cuid())
  stripeEventId  String   @unique
  type           String
  processedAt    DateTime @default(now())

  @@index([stripeEventId])
  @@index([type])
}

model Dispute {
  id              String   @id @default(cuid())
  orderId         String
  order           Order    @relation(fields: [orderId], references: [id])
  stripeDisputeId String   @unique
  amount          Decimal  @db.Decimal(10, 2)
  reason          String
  status          String
  evidence_due_by DateTime
  resolved_at     DateTime?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([orderId])
  @@index([status])
}
