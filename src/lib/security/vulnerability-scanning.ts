/**
 * Vulnerability Scanning
 * Semana 42, Tarea 42.7: Vulnerability Scanning
 */

import { logger } from '@/lib/monitoring'

export interface Vulnerability {
  id: string
  name: string
  severity: 'low' | 'medium' | 'high' | 'critical'
  cveId?: string
  affectedComponent: string
  discoveredDate: Date
  description: string
  remediation?: string
  status: 'open' | 'in_progress' | 'fixed' | 'acknowledged'
}

export interface ScanResult {
  id: string
  scanDate: Date
  scanType: 'dependency' | 'code' | 'infrastructure'
  totalIssues: number
  vulnerabilitiesFound: Vulnerability[]
  summary: string
}

export interface DependencyVulnerability {
  packageName: string
  currentVersion: string
  vulnerableVersion: string
  fixedVersion?: string
  severity: string
  cvss?: number
}

export class VulnerabilityScanner {
  private vulnerabilities: Map<string, Vulnerability> = new Map()
  private scanResults: Map<string, ScanResult> = new Map()
  private dependencyDatabase: Map<string, DependencyVulnerability[]> = new Map()

  constructor() {
    logger.debug({ type: 'vulnerability_scanner_init' }, 'Vulnerability Scanner inicializado')
    this.initializeDependencyDatabase()
  }

  /**
   * Inicializar base de datos de dependencias
   */
  private initializeDependencyDatabase(): void {
    // Ejemplo de vulnerabilidades conocidas
    this.dependencyDatabase.set('lodash', [
      {
        packageName: 'lodash',
        currentVersion: '4.17.19',
        vulnerableVersion: '< 4.17.21',
        fixedVersion: '4.17.21',
        severity: 'high',
        cvss: 7.5,
      },
    ])

    this.dependencyDatabase.set('express', [
      {
        packageName: 'express',
        currentVersion: '4.17.1',
        vulnerableVersion: '< 4.18.0',
        fixedVersion: '4.18.0',
        severity: 'medium',
        cvss: 5.3,
      },
    ])
  }

  /**
   * Escanear dependencias
   */
  scanDependencies(dependencies: Record<string, string>): ScanResult {
    const vulnerabilitiesFound: Vulnerability[] = []

    for (const [packageName, version] of Object.entries(dependencies)) {
      const knownVulnerabilities = this.dependencyDatabase.get(packageName)

      if (knownVulnerabilities) {
        for (const vuln of knownVulnerabilities) {
          if (this.isVersionVulnerable(version, vuln.vulnerableVersion)) {
            const vulnerability: Vulnerability = {
              id: `vuln_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              name: `${packageName} - ${vuln.severity}`,
              severity: vuln.severity as any,
              affectedComponent: packageName,
              discoveredDate: new Date(),
              description: `Vulnerability in ${packageName} version ${version}`,
              remediation: `Upgrade to ${vuln.fixedVersion}`,
              status: 'open',
            }

            vulnerabilitiesFound.push(vulnerability)
            this.vulnerabilities.set(vulnerability.id, vulnerability)
          }
        }
      }
    }

    const result: ScanResult = {
      id: `scan_${Date.now()}`,
      scanDate: new Date(),
      scanType: 'dependency',
      totalIssues: vulnerabilitiesFound.length,
      vulnerabilitiesFound,
      summary: `Found ${vulnerabilitiesFound.length} vulnerabilities`,
    }

    this.scanResults.set(result.id, result)

    logger.info(
      { type: 'dependency_scan_completed', issuesFound: vulnerabilitiesFound.length },
      `Escaneo de dependencias completado`
    )

    return result
  }

  /**
   * Verificar si versión es vulnerable
   */
  private isVersionVulnerable(currentVersion: string, vulnerablePattern: string): boolean {
    // Simplified version comparison
    if (vulnerablePattern.startsWith('<')) {
      const vulnVersion = vulnerablePattern.substring(2)
      return currentVersion.localeCompare(vulnVersion) < 0
    }
    return false
  }

  /**
   * Escanear código (SAST)
   */
  scanCode(codeMetrics: { files: number; linesOfCode: number; issuesDetected: number }): ScanResult {
    const vulnerabilitiesFound: Vulnerability[] = []

    // Simular detección de problemas de código
    if (codeMetrics.issuesDetected > 0) {
      vulnerabilitiesFound.push({
        id: `vuln_${Date.now()}`,
        name: 'Code Quality Issues',
        severity: codeMetrics.issuesDetected > 10 ? 'high' : 'medium',
        affectedComponent: 'codebase',
        discoveredDate: new Date(),
        description: `${codeMetrics.issuesDetected} security issues detected`,
        status: 'open',
      })
    }

    const result: ScanResult = {
      id: `scan_${Date.now()}`,
      scanDate: new Date(),
      scanType: 'code',
      totalIssues: vulnerabilitiesFound.length,
      vulnerabilitiesFound,
      summary: `Code scan: ${codeMetrics.files} files, ${codeMetrics.linesOfCode} LOC, ${codeMetrics.issuesDetected} issues`,
    }

    this.scanResults.set(result.id, result)

    logger.info({ type: 'code_scan_completed' }, 'Escaneo de código completado')

    return result
  }

  /**
   * Reportar vulnerabilidad
   */
  reportVulnerability(
    name: string,
    severity: string,
    component: string,
    description: string
  ): Vulnerability {
    const vuln: Vulnerability = {
      id: `vuln_${Date.now()}`,
      name,
      severity: severity as any,
      affectedComponent: component,
      discoveredDate: new Date(),
      description,
      status: 'open',
    }

    this.vulnerabilities.set(vuln.id, vuln)

    logger.warn(
      { type: 'vulnerability_reported', name, severity, component },
      `Vulnerabilidad reportada: ${name}`
    )

    return vuln
  }

  /**
   * Marcar como remediada
   */
  markAsFixed(vulnerabilityId: string): Vulnerability | null {
    const vuln = this.vulnerabilities.get(vulnerabilityId)
    if (vuln) {
      vuln.status = 'fixed'
      logger.info({ type: 'vulnerability_fixed', vulnerabilityId }, 'Vulnerabilidad marcada como remediada')
    }
    return vuln || null
  }

  /**
   * Obtener vulnerabilidades abiertas
   */
  getOpenVulnerabilities(): Vulnerability[] {
    return Array.from(this.vulnerabilities.values()).filter((v) => v.status === 'open')
  }

  /**
   * Obtener vulnerabilidades críticas
   */
  getCriticalVulnerabilities(): Vulnerability[] {
    return Array.from(this.vulnerabilities.values()).filter((v) => v.severity === 'critical')
  }

  /**
   * Generar reporte de escaneo
   */
  generateScanReport(): string {
    const openVulns = this.getOpenVulnerabilities()
    const criticalVulns = this.getCriticalVulnerabilities()

    const bySeverity: Record<string, number> = {}
    for (const vuln of this.vulnerabilities.values()) {
      bySeverity[vuln.severity] = (bySeverity[vuln.severity] || 0) + 1
    }

    const report = `
=== REPORTE DE VULNERABILIDADES ===

RESUMEN:
- Total de Vulnerabilidades: ${this.vulnerabilities.size}
- Vulnerabilidades Abiertas: ${openVulns.length}
- Vulnerabilidades Críticas: ${criticalVulns.length}

DISTRIBUCIÓN POR SEVERIDAD:
${Object.entries(bySeverity)
  .map(([severity, count]) => `- ${severity}: ${count}`)
  .join('\n')}

ÚLTIMOS ESCANEOS:
${Array.from(this.scanResults.values())
  .slice(-5)
  .map((r) => `- ${r.scanType}: ${r.scanDate.toISOString()} - ${r.totalIssues} problemas`)
  .join('\n')}

VULNERABILIDADES CRÍTICAS:
${criticalVulns.length > 0 ? criticalVulns.map((v) => `- ${v.name}: ${v.affectedComponent}`).join('\n') : '- Ninguna'}
    `

    logger.info({ type: 'vulnerability_report_generated' }, 'Reporte de vulnerabilidades generado')
    return report
  }

  /**
   * Obtener estadísticas
   */
  getStatistics(): {
    totalVulnerabilities: number
    openVulnerabilities: number
    criticalVulnerabilities: number
    fixedVulnerabilities: number
    totalScans: number
  } {
    const vulns = Array.from(this.vulnerabilities.values())

    return {
      totalVulnerabilities: vulns.length,
      openVulnerabilities: vulns.filter((v) => v.status === 'open').length,
      criticalVulnerabilities: vulns.filter((v) => v.severity === 'critical').length,
      fixedVulnerabilities: vulns.filter((v) => v.status === 'fixed').length,
      totalScans: this.scanResults.size,
    }
  }
}

let globalVulnerabilityScanner: VulnerabilityScanner | null = null

export function initializeVulnerabilityScanner(): VulnerabilityScanner {
  if (!globalVulnerabilityScanner) {
    globalVulnerabilityScanner = new VulnerabilityScanner()
  }
  return globalVulnerabilityScanner
}

export function getVulnerabilityScanner(): VulnerabilityScanner {
  if (!globalVulnerabilityScanner) {
    return initializeVulnerabilityScanner()
  }
  return globalVulnerabilityScanner
}
